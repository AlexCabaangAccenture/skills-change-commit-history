using Azure.Messaging.ServiceBus;
using CAT.App.D365.Service.Core.Models;
using CAT.App.D365.Service.Core.Utilities.Interface;
using DocumentFormat.OpenXml.Drawing;
using Microsoft.Azure.Amqp.Framing;
using Microsoft.Extensions.Configuration;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Polly;
using Polly.Timeout;
using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;

namespace CAT.App.D365.Service.Core.Utilities
{
    public class AzureServiceBusService : IAzureServiceBusService
    {
        private readonly IHttpClientFactory _clientFactory;
        private readonly IConfiguration _config;
        private string _asbConnString;
        private static readonly int maxRetryAttempts = 3;
        private static readonly TimeSpan pauseBetweenFailures = TimeSpan.FromSeconds(5);
        private static readonly TimeSpan maxDelay = TimeSpan.FromSeconds(30);

        private static readonly IAsyncPolicy PollyRetryPolicy = Policy
            .Handle<Exception>()
            .WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures,
                (exception, timeSpan, retryCount, context) =>
                {
                    Console.WriteLine($"Retry {retryCount} of {maxRetryAttempts}. Waiting {timeSpan} before next retry.");
                });

        private static readonly IAsyncPolicy PollyTimeOutPolicy = Policy
            .TimeoutAsync(TimeSpan.FromSeconds(60), TimeoutStrategy.Pessimistic,(context, timespan, task) =>
                {
                    Console.WriteLine($"Timedout after {timespan.TotalSeconds} seconds.");
                    return Task.CompletedTask; 
                });

        private static readonly IAsyncPolicy PollyPolicy = Policy.WrapAsync(PollyRetryPolicy, PollyTimeOutPolicy);

        public AzureServiceBusService(IHttpClientFactory clientFactory, IConfiguration config)
        {
            _clientFactory = clientFactory;
            _config = config;
            _asbConnString = GetConfigValue("ASBConnectionString");
        }

        public async Task<string> ASBGetMessageApiCallAsync(string transactionType, IRequestCriteria? criteria)
        {
            string queueName = string.Empty;
            List<string> responseList = new List<string>();
            bool stat = true;

            Dictionary<string, List<object>> respDict = new Dictionary<string, List<object>>();

            switch (transactionType.ToLower())
            {
                case "general":
                    {
                        queueName = GeneralConstants.GENERAL_JOURNAL_POSTED_QUEUENAME;
                        break;
                    }
                case "emsfi":
                    {
                        queueName = GeneralConstants.EMSFI_JOURNAL_POSTED_QUEUENAME;
                        break;
                    }
                case "notes":
                    {
                        queueName = GeneralConstants.NOTES_JOURNAL_POSTED_QUEUENAME;
                        break;
                    }
                default:
                    {
                        queueName = GeneralConstants.GENERAL_JOURNAL_POSTED_QUEUENAME;
                        break;
                    }
            }

            await using ServiceBusClient client = new ServiceBusClient(_asbConnString);

            ServiceBusReceiverOptions receiverOptions = new ServiceBusReceiverOptions
            {
                ReceiveMode = ServiceBusReceiveMode.PeekLock,
                PrefetchCount = 10
            };

            ServiceBusReceiver serviceBusReceiver = client.CreateReceiver(queueName, receiverOptions);

            try
            {
                while (stat)
                {
                    await PollyPolicy.ExecuteAsync(async () =>
                    {
                        ServiceBusReceivedMessage peekMessage = await serviceBusReceiver.PeekMessageAsync();
                        if (peekMessage != null)
                        {
                            MessageTypeModel? processMessage = IsMessageForProcessing(transactionType, criteria, peekMessage.Body.ToString()); //Use peekMessage.Body.ToString()!
                            if (processMessage != null && processMessage.MessageBody != null)
                            {
                                ProcessResponseDictionary(transactionType, processMessage, respDict, peekMessage.Body);

                                ServiceBusReceivedMessage receiveMessage = await serviceBusReceiver.ReceiveMessageAsync();
                                if (receiveMessage != null)
                                {
                                    responseList.Add(receiveMessage.Body.ToString());
                                    await serviceBusReceiver.CompleteMessageAsync(receiveMessage);
                                }
                            }
                        }
                        else
                        {
                            stat = false;
                        }
                    });
                }
            }
            catch (TimeoutRejectedException timeoutEx)
            {
                throw new TimeoutRejectedException(timeoutEx.Message);
            }
            catch (Exception ex)
            {
                throw new Exception(ex.Message);
            }
            finally
            {
                {
                    await serviceBusReceiver.DisposeAsync();
                    await client.DisposeAsync();
                }
            }

            return JsonConvert.SerializeObject(respDict);
        }

        public async Task<List<string>> ASBGetMessageAPICallAsync(string criteria)
        {
            var responseList = new List<string>();
            return responseList;
        }

        public async Task<string> ASBSendMessageApiCallAsync(string asbMessage)
        {
            string returnMessage = string.Empty;
            var retryPolicy = Policy
                .Handle<Exception>()
                .WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures,
                    (exception, timeSpan, retryCount, context) =>
                    {
                        Console.WriteLine($"Retry {retryCount} of {maxRetryAttempts}. Waiting {timeSpan} before next retry. Retrying due to: {exception.Message}");
                    });

            var clientOptions = new ServiceBusClientOptions
            {
                RetryOptions = new ServiceBusRetryOptions
                {
                    Mode = ServiceBusRetryMode.Exponential,
                    MaxRetries = maxRetryAttempts,
                    Delay = pauseBetweenFailures,
                    MaxDelay = maxDelay
                }
            };

            await using ServiceBusClient serviceBusClient = new ServiceBusClient(_asbConnString, clientOptions);
            
            ServiceBusSender serviceBusSender = serviceBusClient.CreateSender(GeneralConstants.GENERAL_JOURNAL_POSTED_QUEUENAME);

            await retryPolicy.ExecuteAsync(async () =>
            {
                ServiceBusMessage message = new ServiceBusMessage(asbMessage);
                
                await serviceBusSender.SendMessageAsync(message);

                returnMessage = $"Message sent successfully. Message Details: {asbMessage}";

                await serviceBusSender.CloseAsync();
            });

            return returnMessage;
        }

        public async Task<string> ASBSendBatchMessageApiCallAsync(string asbMessage, string transactionType)
        {
            string returnMessage = string.Empty;
            string queueName = string.Empty;

            dynamic? messages = JsonConvert.DeserializeObject<dynamic>(asbMessage);
            List<string> sentMessage = new List<string>();
            var retryPolicy = Policy
                .Handle<Exception>()
                .WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures,
                    (exception, timeSpan, retryCount, context) =>
                    {
                        Console.WriteLine($"Retry {retryCount} of {maxRetryAttempts}. Waiting {timeSpan} before next retry. Retrying due to: {exception.Message}");
                    });

            var clientOptions = new ServiceBusClientOptions
            {
                RetryOptions = new ServiceBusRetryOptions
                {
                    Mode = ServiceBusRetryMode.Exponential,
                    MaxRetries = maxRetryAttempts,
                    Delay = pauseBetweenFailures,
                    MaxDelay = maxDelay
                }
            };

            await using ServiceBusClient serviceBusClient = new ServiceBusClient(_asbConnString, clientOptions);
            switch (transactionType.ToLower())
            {
                case "general":
                    {
                        queueName = GeneralConstants.GENERAL_JOURNAL_POSTED_QUEUENAME;
                        break;
                    }
                case "emsfi":
                    {
                        queueName = GeneralConstants.EMSFI_JOURNAL_POSTED_QUEUENAME;
                        break;
                    }
                case "notes":
                    {
                        queueName = GeneralConstants.NOTES_JOURNAL_POSTED_QUEUENAME;
                        break;
                    }
                default:
                    {
                        queueName = GeneralConstants.GENERAL_JOURNAL_POSTED_QUEUENAME;
                        break;
                    }
            }
            ServiceBusSender serviceBusSender = serviceBusClient.CreateSender(queueName);

            await retryPolicy.ExecuteAsync(async () =>
            {
                ServiceBusMessage message = new ServiceBusMessage(asbMessage);
                using ServiceBusMessageBatch messageBatch = await serviceBusSender.CreateMessageBatchAsync();
                foreach (var messageContent in messages.requestData)
                {
                    if (!messageBatch.TryAddMessage(new ServiceBusMessage(messageContent.ToString())))
                    {
                        throw new Exception("The message is too large to fit in the batch.");
                    }
                    sentMessage.Add(messageContent.ToString());
                }

                await serviceBusSender.SendMessagesAsync(messageBatch);
                string successfullySentMessages = JsonConvert.SerializeObject(sentMessage);
                returnMessage = $"Message sent successfully. Message Details: {successfullySentMessages}";

                await serviceBusSender.CloseAsync();
            });

            return returnMessage;
        }

        private string GetConfigValue(string setting)
        {
            return _config[$"AppSettings:{setting}"] ?? _config[setting];
        }

        private MessageTypeModel? IsMessageForProcessing(string transactionType, IRequestCriteria? criteria, string targetMsg)
        {
            try
            {
                MessageTypeModel result;
                if (criteria != null && transactionType.ToLower() != TransactionTypes.GENERAL.ToLower())
                {
                    var sbResponse = JsonConvert.DeserializeObject<ServiceBusMessageResponse>(targetMsg);
                    var target = MessageProcessorHelper.ConvertToDictionary(sbResponse);

                    if (target == null)
                        return null;

                    var criteriaDict = MessageProcessorHelper.ConvertCriteriaToDictionary(transactionType, criteria);
                    var flatCriteria = MessageProcessorHelper.FlattenCriteria(criteriaDict);

                    var match = MessageProcessorHelper.GetMatches(flatCriteria, target);

                    result = new MessageTypeModel()
                    {
                        TransactionType = transactionType,
                        TransactionStatus = match.FirstOrDefault().Key,
                        MessageBody = match.FirstOrDefault().Value
                    };
                }
                else //general
                {
                    result = new MessageTypeModel()
                    {
                        TransactionType = transactionType,
                        TransactionStatus = transactionType,
                        MessageBody = JsonConvert.DeserializeObject<object?>(targetMsg)
                    };
                }

                return result;
            }
            catch (Exception ex)
            {
                return null;
            }
        }

        private void ProcessResponseDictionary(string transactionType, MessageTypeModel? processMessage, Dictionary<string, List<object>> respDict, object messageBody)
        {
            switch (transactionType)
            {
                case TransactionTypes.NOTES:
                case TransactionTypes.EMSFI:
                    if (respDict.ContainsKey(processMessage.TransactionStatus))
                        respDict[processMessage.TransactionStatus].Add(JsonConvert.DeserializeObject(processMessage.MessageBody.ToString()));
                    else
                        respDict[processMessage.TransactionStatus] = new List<object> { JsonConvert.DeserializeObject(processMessage.MessageBody.ToString()) };
                    break;
                case TransactionTypes.GENERAL:
                    if (respDict.ContainsKey(TransactionTypes.GENERAL))
                        respDict[TransactionTypes.GENERAL].Add(JsonConvert.DeserializeObject(messageBody.ToString()));
                    else
                        respDict[TransactionTypes.GENERAL] = new List<object> { JsonConvert.DeserializeObject(messageBody.ToString()) };
                    break;
                default:
                    break;
            }
            

        }

    }
}
